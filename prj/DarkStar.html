<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>3D BUBBLEs</title>
	<style>
		body {
			width: 100;
			background-color: black;
			background-image: radial-gradient(white 5%, black 90%);
			margin: 0px;
		}
	</style>
</head>

<body>
	<script src="./lib/three.js"></script>
	<script type="module">
		import { GUI } from '../lib/dat.gui.module.js';
		// 窗口
		//const windowW = window.innerWidth;
		//const windowH = window.innerHeight;
		//window.moveTo(0,0);
		//window.resizeTo(windowH/2,windowH);
		//window.onresize=new Function("window.resizeTo(windowH/2,windowH);") 

		// 全局参数设置
		var bubbles = [];
		var bubblePlay = [];
		var button = [];
		var buttonRecord = null;
		var buttonRecordAero = null;

		var StartPos = 0;
		var DisCamera2Start = 250;
		var DisLight2Start = 60;
		var DisButton2Start = DisCamera2Start * 0.9;
		var rate = 2;
		var MoveCameraSpeed = 0.2 * rate;
		var MoveBubbleSpeedMax = 0.4 * rate;
		var BubbleRotateSpeed = 0.003 * rate;
		var CreateBubbleFrame = 100 / rate;

		var AudioPlayState = 0;
		var RecordState = 0; // 0: Not Recording, 1: Recording
		var debugState = {
			PointLightPos: DisLight2Start,
			CameraPos: DisCamera2Start,
			bubbleSpeedXYmax: MoveBubbleSpeedMax,
			bubbleSpeedZmaz: MoveCameraSpeed,
			bubbleRotateSpeed: BubbleRotateSpeed,
		};
		var ObjectType = {
			bubble: 0,
			bubblePlay: 1,
			buttonRecord: 2,
		};

		var vertexShader = [
			'varying vec3	vVertexWorldPosition;',
			'varying vec3	vVertexNormal;',
			'varying vec4	vFragColor;',
			'void main(){',
			'	vVertexNormal	= normalize(normalMatrix * normal);',//将法线转换到视图坐标系中
			'	vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;',//将顶点转换到世界坐标系中
			'	// set gl_Position',
			'	gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
			'}'

		].join('\n');

		//大气层效果
		THREE.AeroSphere = {
			uniforms: {
				coeficient: {
					type: "f",
					value: 1.0
				},
				power: {
					type: "f",
					value: 2
				},
				glowColor: {
					type: "c",
					value: new THREE.Color(0xffffff)
				}
			},
			vertexShader: vertexShader,
			fragmentShader: [
				'uniform vec3	glowColor;',
				'uniform float	coeficient;',
				'uniform float	power;',

				'varying vec3	vVertexNormal;',
				'varying vec3	vVertexWorldPosition;',

				'varying vec4	vFragColor;',

				'void main(){',
				'	vec3 worldCameraToVertex= vVertexWorldPosition - cameraPosition;',	//世界坐标系中从相机位置到顶点位置的距离
				'	vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;',//视图坐标系中从相机位置到顶点位置的距离
				'	viewCameraToVertex	= normalize(viewCameraToVertex);',//规一化
				'	float intensity		= pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);',
				'	gl_FragColor		= vec4(glowColor, intensity);',
				'}'//vVertexNormal视图坐标系中点的法向量
				//viewCameraToVertex视图坐标系中点到摄像机的距离向量
				//dot点乘得到它们的夹角的cos值
				//从中心向外面角度越来越小（从钝角到锐角）从cos函数也可以知道这个值由负变正，不透明度最终从低到高
			].join('\n')
		}

		//辉光效果Glow
		THREE.GlowSphere = {
			uniforms: {
				coeficient: {
					type: "f",
					value: 1
				},
				power: {
					type: "f",
					value: 1
				},
				glowColor: {
					type: "c",
					value: new THREE.Color(0x0fffff)
				}
			},
			vertexShader: vertexShader,
			fragmentShader: [
				'uniform vec3	glowColor;',
				'uniform float	coeficient;',
				'uniform float	power;',

				'varying vec3	vVertexNormal;',
				'varying vec3	vVertexWorldPosition;',

				'varying vec4	vFragColor;',

				'void main(){',
				'	vec3 worldVertexToCamera= cameraPosition - vVertexWorldPosition;',	//世界坐标系中顶点位置到相机位置到的距离
				'	vec3 viewCameraToVertex	= (viewMatrix * vec4(worldVertexToCamera, 0.0)).xyz;',//视图坐标系中从相机位置到顶点位置的距离
				'	viewCameraToVertex	= normalize(viewCameraToVertex);',//规一化
				'	float intensity		= coeficient + dot(vVertexNormal, viewCameraToVertex);',
				'	if(intensity > 0.65){ intensity = 0.0;}',
				'	gl_FragColor		= vec4(glowColor, intensity);',
				'}'//vVertexNormal视图坐标系中点的法向量
				//viewCameraToVertex视图坐标系中点到摄像机的距离向量
				//dot点乘得到它们的夹角的cos值
				//从中心向外面角度越来越大（从锐角到钝角）从cos函数也可以知道这个值由负变正，不透明度最终从高到低
			].join('\n')
		}


		// 设置场景和摄像机
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
		camera.position.z = StartPos + DisCamera2Start;

		// 设置渲染器
		const renderer = new THREE.WebGLRenderer({ alpha: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		// 设置点光源
		//const LightSphere = new THREE.SphereGeometry( 10, 16, 8 );
		var PointLight = new THREE.PointLight(0xffffff, 100, 0);
		//PointLight.add( new THREE.Mesh( LightSphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
		PointLight.visible = true;
		PointLight.position.z = StartPos + DisLight2Start;
		scene.add(PointLight);

		var PointLight2 = new THREE.PointLight(0xffffff, 0.3, 0);
		//PointLight.add( new THREE.Mesh( LightSphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
		PointLight2.visible = true;
		PointLight2.position.z = StartPos + DisCamera2Start * 2;
		scene.add(PointLight2);

		// 鼠标点击
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();
		window.addEventListener('click', onMouseClick, false);

		// 开始
		Start();

		/*** 函数 ***/

		// 开始
		function Start() {
			// GUI
			CreateGUI();
			// 生成气泡
			CreateRecordButton();
			setInterval(CreateBubbles, CreateBubbleFrame);
			// 运动动画
			animate();
		}

		function CreateGUI() {
			const gui = new GUI();
			gui.add(debugState, 'PointLightPos', 1, 200, 1).onChange(e => { DisLight2Start = e });
			//gui.add( debugState, 'ChangeRate', 0.1, 10).onChange( e => { rate = e} );
			gui.add(debugState, 'CameraPos', 100, 400, 10).onChange(e => { DisCamera2Start = e });
			gui.add(debugState, 'bubbleSpeedXYmax', 0.01, 2.0, 0.01).onChange(e => { MoveBubbleSpeedMax = e });
			gui.add(debugState, 'bubbleSpeedZmaz', 0.01, 2.0, 0.01).onChange(e => { MoveCameraSpeed = e });
			gui.add(debugState, 'bubbleRotateSpeed', 0.001, 0.02, 0.001).onChange(e => { BubbleRotateSpeed = e });
		}
		// 单击事件
		function onMouseClick(event) {
			//通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

			// 通过鼠标点的位置和当前相机的矩阵计算出raycaster
			raycaster.setFromCamera(mouse, camera);

			// 获取raycaster直线和所有模型相交的数组集合
			var intersects = raycaster.intersectObjects(scene.children);

			// console.log('集合',intersects);

			//将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可
			if (!intersects.length) {
				return;
			}
			let obj = intersects[0].object;
			var tmpPos = obj.position;
			var tmpParam = obj.param;

			if (ObjectType.bubble == obj.param.type) {
				scene.remove(obj);
				//console.log(obj.position);
				CreateBubblePlay(tmpPos, tmpParam);
			}
			if (ObjectType.buttonRecord == obj.param.type && RecordState == 0) {
				RecordState = 1;
				/***
				var materialAero = new THREE.ShaderMaterial({
					uniforms: THREE.AeroSphere.uniforms,
					vertexShader: THREE.AeroSphere.vertexShader,
					fragmentShader: THREE.AeroSphere.fragmentShader,
					blending: THREE.NormalBlending,
					transparent: true,
					opacity: 0,
					depthWrite:true
				});
				//obj.param.isClicked = 1;
				//console.log("cliked")
				RecordState = 1;
				scene.remove( buttonRecord );
				scene.remove( buttonRecordAero );
				var cubic_button = new THREE.BoxGeometry(1.1, 1.1, 1.1);
				buttonRecord = new THREE.Mesh(cubic_button,  new THREE.MeshBasicMaterial({color:0xff0000}));
				buttonRecord.position.x=tmpPos.x;
				buttonRecord.position.y=tmpPos.y;
				buttonRecord.position.z=tmpPos.z;
				//bubbles_aero.push(mesh);
				buttonRecord.param = tmpParam;
				scene.add(buttonRecord);

				var cubic_aero = new THREE.BoxGeometry(1.3, 1.3, 1.3);
				buttonRecordAero = new THREE.Mesh(cubic_aero, materialAero);
				buttonRecordAero.position.x=tmpPos.x;
				buttonRecordAero.position.y=tmpPos.y;
				buttonRecordAero.position.z=tmpPos.z;
				//bubbles_aero.push(mesh);
				buttonRecordAero.param = tmpParam;
				scene.add(buttonRecordAero);
				***/
			}
		}

		//
		function CreateRecordButton() {
			var materialAero = new THREE.ShaderMaterial({
				uniforms: THREE.AeroSphere.uniforms,
				vertexShader: THREE.AeroSphere.vertexShader,
				fragmentShader: THREE.AeroSphere.fragmentShader,
				blending: THREE.NormalBlending,
				transparent: true,
				opacity: 0,
				depthWrite: true
			});
			var buttonParam = {
				type: ObjectType.buttonRecord,
			};
			//console.log(material1);
			var sphereButton = new THREE.SphereGeometry(1.1, 60, 60);
			buttonRecord = new THREE.Mesh(sphereButton, materialAero);
			buttonRecord.position.x = 0;
			buttonRecord.position.y = -7;
			buttonRecord.position.z = StartPos + DisButton2Start;
			//bubbles_aero.push(mesh);
			buttonRecord.param = buttonParam;
			scene.add(buttonRecord);
			button.push(buttonRecord);
			/***
			sphereAero = new THREE.SphereBufferGeometry(1, 60, 60);
			meshAero = new THREE.Mesh(sphereAero, materialAero);
			meshAero.position.x=0;
			meshAero.position.y=-7;
			meshAero.position.z=StartPos + DisButton2Start;
			//bubbles_aero.push(mesh);
			//scene.add(meshAero);
			***/
			var sphereAero = null;
			sphereAero = new THREE.SphereGeometry(0.4, 60, 60);
			buttonRecordAero = new THREE.Mesh(sphereAero, new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 }));
			buttonRecordAero.position.x = 0 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.y = -7 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.z = StartPos + DisButton2Start;
			buttonRecordAero.param = buttonParam;
			scene.add(buttonRecordAero);
			button.push(buttonRecordAero);

			sphereAero = new THREE.SphereGeometry(0.5, 60, 60);
			buttonRecordAero = new THREE.Mesh(sphereAero, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 }));
			buttonRecordAero.position.x = 0 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.y = -7 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.z = StartPos + DisButton2Start;
			buttonRecordAero.param = buttonParam;
			scene.add(buttonRecordAero);
			button.push(buttonRecordAero);

			sphereAero = new THREE.SphereGeometry(0.6, 60, 60);
			buttonRecordAero = new THREE.Mesh(sphereAero, new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 }));
			buttonRecordAero.position.x = 0 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.y = -7 + (Math.random() - 0.5) * 1;
			buttonRecordAero.position.z = StartPos + DisButton2Start;
			buttonRecordAero.param = buttonParam;
			scene.add(buttonRecordAero);
			button.push(buttonRecordAero);

		}


		// 生成气泡
		function CreateBubbles() {
			var bubbleParam = {
				//x: (Math.random() - 0.5)*windowW/2,
				//y: (Math.random() - 0.5)*windowH/2,
				//applitude: Math.random(),
				//frequency: Math.random() * 0.01 + 0.01,
				speedX: (Math.random() - 0.5) * MoveBubbleSpeedMax,
				speedY: (Math.random() - 0.5) * MoveBubbleSpeedMax,
				speedZ: (Math.random() - 0.5) * MoveCameraSpeed * 1.5,
				RotSpeed: Math.random() * BubbleRotateSpeed + BubbleRotateSpeed,
				//speedZ: (Math.random() - 0.5)*0.5,
				radiusChange: 0,
				MaxRadius: 0,
				InitRadius: Math.random() * 5 + 2,
				//isClicked: 0,
				type: ObjectType.bubble,
				//color: bubbleColor[Math.floor(Math.random()*bubbleColor.length)],
				//color: Math.random() * 25 + 175,
				//isSpeedChanged:0,
				//lightness: Math.random() * 10 + 65,
				//apcChange: 0.01,
				//apcChangeCnt: 1000,
				//isClicked: 0,
				//apc: 0
			};
			const geometry = new THREE.SphereGeometry(bubbleParam.InitRadius, 30, 30);
			//const material = new THREE.MeshPhongMaterial();

			var texture = new THREE.TextureLoader().load("./tex/cosmos.jfif", res => {
				const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
				//material.map = res;
				material.bumpMap = res;
				material.bumpScale = 0.7;
				var bubble = new THREE.Mesh(geometry, material);

				bubble.position.x = 0;
				bubble.position.y = 0;
				bubble.position.z = StartPos + (Math.random() - 0.5) * 70;
				bubble.param = bubbleParam;
				//PointLight.position.z -= 0.2;
				scene.add(bubble);
				bubbles.push(bubble);
			});
		}

		//球体 辉光 大气层
		function CreateBubblePlay(Pos, Params) {
			// let tmpPara=JSON.parse(JSON.stringify(Params));
			for (let i = 0; i < bubblePlay.length; i++) {
				scene.remove(bubblePlay[i]);
			}

			var materialAero = new THREE.ShaderMaterial({
				uniforms: THREE.AeroSphere.uniforms,
				vertexShader: THREE.AeroSphere.vertexShader,
				fragmentShader: THREE.AeroSphere.fragmentShader,
				blending: THREE.NormalBlending,
				transparent: true,
				opacity: 0,
				depthWrite: false
			});
			var material_glow = new THREE.ShaderMaterial({
				uniforms: THREE.GlowSphere.uniforms,
				vertexShader: THREE.GlowSphere.vertexShader,
				fragmentShader: THREE.GlowSphere.fragmentShader,
				blending: THREE.NormalBlending,
				transparent: false,
			});

			var sphereGlow = new THREE.SphereGeometry(Params.InitRadius, 32, 32);
			var colorGlow = Math.random() * 16777215;
			var bubbleGlow = new THREE.Mesh(sphereGlow, new THREE.MeshBasicMaterial({ color: colorGlow, transparent: true, opacity: 0.7 }));
			bubbleGlow.param = JSON.parse(JSON.stringify(Params));
			bubbleGlow.position.x = Pos.x;
			bubbleGlow.position.y = Pos.y;
			bubbleGlow.position.z = Pos.z;
			bubbleGlow.param.type = ObjectType.bubblePlay;
			/**
			 * 生成大气层
			 * maxTimes 扩大倍数
			*/
			function createAero(maxTimes) {
				let argPara=JSON.parse(JSON.stringify(Params));
				var sphereAero = new THREE.SphereBufferGeometry(argPara.InitRadius, 32, 32);
				var bubbleAero = new THREE.Mesh(sphereAero, materialAero);
				bubbleAero.param = argPara;
				bubbleAero.radius = argPara.InitRadius;
				bubbleAero.param.radiusChange = argPara.InitRadius * 0.2 / 100;
				bubbleAero.param.MaxRadius=argPara.InitRadius*maxTimes;
				bubbleAero.radiusChange = argPara.radiusChange;
				bubbleAero.position.x = Pos.x;
				bubbleAero.position.y = Pos.y;
				bubbleAero.position.z = Pos.z;
				bubbleAero.param.type = ObjectType.bubblePlay;
				return bubbleAero;
			}

			//bubbleAero.param.MaxRadius = Params.InitRadius*1.1;
			/***
			var sphereAero2 = new THREE.SphereBufferGeometry(Params.InitRadius, 32, 32);
			var bubbleAero2 = new THREE.Mesh(sphereAero2, materialAero);
			bubbleAero2.param = Params;
			bubbleAero2.radius = Params.InitRadius;
			bubbleAero2.param.radiusChange = Params.InitRadius*0.2/100;
			bubbleAero2.radiusChange = bubbleAero.param.radiusChange;
			bubbleAero2.position.x = Pos.x;
			bubbleAero2.position.y = Pos.y;
			bubbleAero2.position.z = Pos.z;
			bubbleAero2.param.type = ObjectType.bubblePlay;
			bubbleAero2.param.MaxRadius = Params.InitRadius*1.2;
			***/
			bubblePlay[0] = bubbleGlow;
			bubblePlay[1] = createAero(1.1);
			bubblePlay[2] = createAero(1.5);

			console.log(bubblePlay[0].param.MaxRadius)
			console.log(bubblePlay[1].param.MaxRadius)
			console.log(bubblePlay[2].param.MaxRadius)

			for (let i = 0; i < bubblePlay.length; i++) {
				scene.add(bubblePlay[i]);
			}
		}

		

		function animateBubbleMove() {
			if (bubbles.length > 1000) {
				bubbles.shift();
			}
			// 球体运动
			for (let i = 0; i < bubbles.length; i++) {
				const bubble = bubbles[i];
				/***
				if (bubble.param.type != ObjectType.bubble) {
					bubble.position.z -= MoveCameraSpeed;
					continue;
				}
				***/

				bubble.position.x += bubble.param.speedX;
				bubble.position.y += bubble.param.speedY;
				bubble.position.z += bubble.param.speedZ + MoveCameraSpeed;

				bubble.rotation.x += bubble.param.RotSpeed;
				bubble.rotation.y += bubble.param.RotSpeed;
				bubble.rotation.z += bubble.param.RotSpeed;

				if (bubble.position.z > camera.position.z) {
					scene.remove(bubble);
				}
			}
		}

		function animateBubblePlay() {
			if (bubblePlay.length > 1) {
				for (let i = 1; i < bubblePlay.length; i++) {
					var bubbleAero = bubblePlay[i];
					//console.log(bubblePlay[i].param.MaxRadius)
					scene.remove(bubblePlay[i]);
					if (bubbleAero.radius > bubbleAero.param.MaxRadius) {
						bubbleAero.radiusChange = - bubbleAero.param.radiusChange;
						//aero_opacity=1;
					}
					if (bubbleAero.radius <= bubbleAero.param.InitRadius * 1 + bubbleAero.param.radiusChange) {
						bubbleAero.radiusChange = + bubbleAero.param.radiusChange;
					}

					var materialAero = new THREE.ShaderMaterial({
						uniforms: THREE.AeroSphere.uniforms,
						vertexShader: THREE.AeroSphere.vertexShader,
						fragmentShader: THREE.AeroSphere.fragmentShader,
						blending: THREE.NormalBlending,
						transparent: true,
						opacity: 0,
						depthWrite: true
					});

					var sphereAero = new THREE.SphereBufferGeometry(bubbleAero.radius + bubbleAero.radiusChange, 32, 32);
					var meshAero = new THREE.Mesh(sphereAero, materialAero);
					meshAero.position.x = bubbleAero.position.x;
					meshAero.position.y = bubbleAero.position.y;
					meshAero.position.z = bubbleAero.position.z;
					meshAero.radius = bubbleAero.radius + bubbleAero.radiusChange;
					meshAero.radiusChange = bubbleAero.radiusChange;
					meshAero.param = bubbleAero.param;
					bubblePlay[i] = meshAero;
					scene.add(bubblePlay[i]);
				}
			}
		}

		function animateLightAndCameraMove() {
			camera.position.z = StartPos + DisCamera2Start;
			PointLight.position.z = StartPos + DisLight2Start;
			PointLight2.position.z = StartPos + DisCamera2Start * 2;
		}
		// 生成动画
		function animate() {
			requestAnimationFrame(animate);
			// 摄像机和灯光运动
			animateLightAndCameraMove();
			// 气泡运动
			animateBubbleMove();
			// 点击后气泡播放
			animateBubblePlay();

			if (RecordState == 1) {
				var ball;
				for (let i = 1; i < button.length; i++) {
					ball = button[i];
					//ball.position.x = sin()

				}
			}
			renderer.render(scene, camera);
		};
	</script>
</body>

</html>